import { NextRequest, NextResponse } from 'next/server'
import { createSupabaseAppServerClient } from '@/lib/utils/supabase/server'
import { serverRequestService } from '@/lib/services/requestService'

const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'https://mobile-jarvis-backend.onrender.com'

interface FileMetadata {
  url: string;
  file_type: string;
  filename: string;
  size_bytes: number;
}

interface ProcessMedicalRecordsRequest {
  files: FileMetadata[];
  request_id?: string;
}

export async function POST(request: NextRequest) {
  let requestId: string | undefined;

  try {
    const supabase = await createSupabaseAppServerClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      console.log('Authentication failed - returning 401')
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { data: { session }, error: sessionError } = await supabase.auth.getSession()
    console.log('Session check result:', {
      hasSession: !!session,
      hasAccessToken: !!session?.access_token,
      accessTokenLength: session?.access_token?.length,
      sessionError: sessionError?.message
    })

    if (sessionError || !session?.access_token) {
      console.log('Session validation failed - returning 401')
      return NextResponse.json(
        { error: 'No valid session token' },
        { status: 401 }
      )
    }

    const body = await request.formData()
    const jsonData = body.get('json_data') as string

    if (!jsonData) {
      return NextResponse.json(
        { error: 'json_data field is required' },
        { status: 400 }
      )
    }

    let parsedData: ProcessMedicalRecordsRequest
    try {
      parsedData = JSON.parse(jsonData)
    } catch (parseError) {
      return NextResponse.json(
        { error: 'Invalid JSON data' },
        { status: 400 }
      )
    }

    const { files, request_id } = parsedData

    if (!files || !Array.isArray(files) || files.length === 0) {
      return NextResponse.json(
        { error: 'Files array is required and must contain at least one file' },
        { status: 400 }
      )
    }

    if (files.length > 8) {
      return NextResponse.json(
        { error: 'Maximum 8 files allowed per request' },
        { status: 400 }
      )
    }

    for (const file of files) {
      if (!file.url || !file.file_type || !file.filename || typeof file.size_bytes !== 'number') {
        return NextResponse.json(
          { error: 'Each file must have url, file_type, filename, and size_bytes' },
          { status: 400 }
        )
      }

      if (file.size_bytes > 50 * 1024 * 1024) {
        return NextResponse.json(
          { error: `File ${file.filename} exceeds 50MB limit` },
          { status: 400 }
        )
      }

      const supportedTypes = ['pdf', 'jpeg', 'jpg', 'png', 'csv']
      if (!supportedTypes.includes(file.file_type.toLowerCase())) {
        return NextResponse.json(
          { error: `Unsupported file type: ${file.file_type}. Supported types: ${supportedTypes.join(', ')}` },
          { status: 400 }
        )
      }
    }

    requestId = request_id || `medical-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    console.log('Using request ID:', requestId, request_id ? '(provided by frontend)' : '(generated by backend)')

    try {
      await serverRequestService.createRequest(user.id, {
        request_id: requestId,
        request_type: 'medical_records_processing',
        status: 'pending',
        metadata: {
          files: files,
          fileCount: files.length,
          totalSize: files.reduce((sum, f) => sum + f.size_bytes, 0),
          timestamp: Date.now()
        }
      })
    } catch (requestError) {
      console.error('Failed to create request record:', requestError)
      return NextResponse.json(
        { error: 'Failed to create request record' },
        { status: 500 }
      )
    }

    try {
      await serverRequestService.updateRequestStatus(requestId, 'processing')
    } catch (updateError) {
      console.error('Failed to update request status to processing:', updateError)
    }

    const medicalRecordsRequest = {
      files: files,
      request_id: requestId,
      user_id: user.id
    }

    const formData = new FormData()
    formData.append('json_data', JSON.stringify(medicalRecordsRequest))

    const response = await fetch(`${PYTHON_BACKEND_URL}/api/process_medical_records`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
      },
      body: formData,
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Python backend error details:', {
        status: response.status,
        statusText: response.statusText,
        errorText: errorText
      })
      throw new Error(`Backend error: ${response.status}`)
    }

    const data = await response.json()
    console.log('Python backend success response:', {
      success: data.success,
      processedCount: data.processed_records?.length,
      failedCount: data.failed_records?.length,
      totalPages: data.total_pages,
      processingTime: data.processing_time
    })

    try {
      await serverRequestService.updateRequestStatus(requestId, 'completed', {
        response: data,
        backend_timestamp: Date.now()
      })
    } catch (updateError) {
      console.error('Failed to update request status to completed:', updateError)
    }

    console.log('=== MEDICAL RECORDS API REQUEST SUCCESS ===')
    return NextResponse.json({
      success: data.success,
      message: data.message,
      processed_records: data.processed_records || [],
      failed_records: data.failed_records || [],
      total_pages: data.total_pages || 0,
      total_files: data.total_files || 0,
      processing_time: data.processing_time || 0,
      request_id: requestId,
    })

  } catch (error) {
    console.error('=== MEDICAL RECORDS API REQUEST FAILED ===')
    console.error('Medical records API error:', error)
    console.error('Error stack:', error instanceof Error ? error.stack : 'No stack trace')

    if (typeof requestId !== 'undefined') {
      try {
        await serverRequestService.updateRequestStatus(requestId, 'failed', {
          error: error instanceof Error ? error.message : 'Unknown error',
          error_timestamp: Date.now()
        })
      } catch (updateError) {
        console.error('Failed to update request status to failed:', updateError)
      }
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}